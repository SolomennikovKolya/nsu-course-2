
// ------------------------------------------ CircularBuffer ------------------------------------------ //

CircularBuffer();
Инициализирует пустой буфер с ёмкостью по умолчанию DEFAULT_CAPACITY = 16.
Кидает исключение, если не получилось аллоцировать память.

explicit CircularBuffer(int capacity);
Инициализирует пустой буфер заданной ёмкости capacity. 
Кидает исключение, если capacity <= 0.
Кидает исключение, если не получилось аллоцировать память.

CircularBuffer(int capacity, const valueType &elem);
Инициализирует буфер заданной ёмкости capacity, заполненный элементами elem. 
Кидает исключение, если capacity <= 0.
Кидает исключение, если не получилось аллоцировать память.

CircularBuffer(const CircularBuffer &cb);
Инициализирует буфер такой же как линеаризованный буфер cb.
Кидает исключение, если не получилось аллоцировать память.

~CircularBuffer() noexcept;
Освобождает память от буфера

int size() const noexcept;
Возвращает размер буфера, то есть количество элементов, хранящихся в нём.

int capacity() const noexcept;
Возвращает ёмкость буфера, то есть максимальное количество элементов, которое может в нём поместиться.

bool empty() const noexcept;
Проверяет, пустой буфер или нет. Возвращает true, если пустой.

bool full() const noexcept;
Проверяет, полный буфер или нет. Возвращает true, если полный.

int reserve() const noexcept;
Возвращает количество свободных ячеек в буфере.

valueType &operator[](int i);
Даёт доступ к элементу буфера с индексом i. Индекс отсчитывается с нуля. 
Индекс i может быть меньше нуля или больше размера буфера, в этом случае индекс искомого элемента берётся по модулю размера буфера.
Кидается исключение, если буфер пустой.

const valueType &operator[](int i) const;
Даёт доступ к элементу буфера с индексом i без возможности изменения. Индекс отсчитывается с нуля. 
Индекс i может быть меньше нуля или больше размера буфера, в этом случае индекс искомого элемента берётся по модулю размера буфера.
Кидается исключение, если буфер пустой.

valueType &at(int i);
Даёт доступ к элементу буфера с индексом i.
Кидается исключение, если индекс i выходит за пределы отрезка [0, size() - 1]. 
Кидается исключение, если буфер пустой.

const valueType &at(int i) const;
Даёт доступ к элементу буфера с индексом i без возможности изменения. 
Кидается исключение, если индекс i выходит за пределы отрезка [0, size() - 1]. 
Кидается исключение, если буфер пустой.

valueType &front();
Возвращяет ссылку на первый элемент.
Кидает исключение, если буфер пустой.

valueType &back();
Возвращяет ссылку на последний элемент.
Кидает исключение, если буфер пустой.

const valueType &front() const;
Возвращяет константную ссылку на первый элемент.
Кидает исключение, если буфер пустой.

const valueType &back() const;
Возвращяет константную ссылку на последний элемент.
Кидает исключение, если буфер пустой.

bool is_linearized() const noexcept;
Проверяет, является ли буфер линеаризованным, то есть возвращает true, если первый элемент находится в начале аллоцированной памяти.

valueType *linearize() noexcept;
Линеаризует буфер, то есть сдвигает его так, что его первый элемент перемещается в начало аллоцированной памяти. 
Возвращает указатель на первый элемент (начало аллоцированной памяти). Возвращает nullptr, если буффер пустой.
Асимптотика: O(size)

void rotate(int newBegin) noexcept;
Сдвигает буфер так, что по нулевому индексу окажется элемент с индексом newBegin (буфер "крутится" влево на newBegin ячеек).
newBegin может быть как меньше нуля, так и больше размера буфера. В этом случае newBegin берётся по модулю размера буфера.
Вместе со сдвигом, как побочный эффект, происходит линеаризация.
Асимптотика: O(size)

void set_capacity(int newCapacity);
Изменяет ёмкость буфера.
Если newCapacity <= 0, то кидается исключение.
Иначе явно реаллоцирует буфер (из за этого может случиться исключение) и линеаризует буфер.
Если новая ёмкость меньше чем размер буфера, то последние элементы удаляются из буфера, сохраняются только первые newCapacity элементов.
Асимптотика: O(size)

void resize(int newSize, const valueType &item);
Изменяет размер буфера. 
Если newSize < 0, то кидается исключение.
Если newSize меньше предыдущего размера буфера, то последние элементы удаляются из буфера, сохраняются только первые newSize элементов.
Если newSize равно  предыдущему рузмеру буфера, то ничего не происходит.
Если newSize больше предыдущего размера буфера, то новые элементы заполняются элементом item, при этом если newSize превышает предыдущую ёмкость буфера, 
то буфер изменяет свою ёмкость до newSize (из за этого может случиться исключение).

CircularBuffer &operator=(const CircularBuffer &cb);
Присваивает исходному буферу буфер cb. При этом эти буферы будут указывать на различные участки памяти.
Кидает исключение, если не получилось аллоцировать память.

void swap(CircularBuffer &cb);
Меняет два буфера местами.
Кидает исключение, если не получилось аллоцировать память.

void push_back(const valueType &item) noexcept;
Добавляет элемент в конец буфера. Если текущий размер буфера равен его ёмкости, то переписывается первый элемент буфера.

void push_front(const valueType &item) noexcept;
Добавляет новый элемент перед первым элементом буфера. Если текущий размер буфера равен его ёмкости, то переписывается последний элемент буфера.

void pop_back() noexcept;
Удаляет последний элемент буфера. Если буфер пустой, то ничего не происходит.

void pop_front() noexcept;
Удаляет первый элемент буфера. Если буфер пустой, то ничего не происходит.

void insert(int pos, const valueType &item);
Вставляет элемент item по индексу pos. Ёмкость буфера остается неизменной. 
Если текущий размер буфера равен его ёмкости, то кидается исключение.

void erase(int first, int last) noexcept;
Удаляет элементы из буфера в полуинтервале [first, last). 
Границы этого полуинтервала могут быть меньше 0 или больше размера буфера. В этом случае они бурутся по модулю размера буфера.

void clear() noexcept;
Очищает буфер.

void print() const noexcept;
Выводит на экран буфер от первого элемента до последнего. Количество напечатанных элементов равно размеру буфера.
Также выводит на экран размер и ёмкость буфера.

void printBufferInMemory() const noexcept; 
Выводит на экран буфер в точности так, как он аллоцирован в памяти. Нижние подчёркивания - не используемые ячейки.

bool operator==(const CircularBuffer<valueType> &a, const CircularBuffer<valueType> &b)
Проверяет на равенство два буфера. (буферы равны даже если они расположены в памяти по разноми)

bool operator!=(const CircularBuffer<valueType> &a, const CircularBuffer<valueType> &b)
Проверяет на неравенство два буфера.

// ------------------------------------------ ITERATOR ------------------------------------------ //

Итератор может быть определён любым целлым числом, так как подразумевается, что буфер закольцован, 
но не факт, что итератор будет корректно работать при изменении размера или ёмкости буфера.
После любых арифметических операций с итератором (даже если итератор выйдет за пределы буфера), его всё ещё можно будет разыменовать, 
но сравнение итераторов может работать не так, как ожидается.

iterator(CircularBuffer &cb, int beginIndex) noexcept;
Инициализация итератора, который указывает на элемент с индексом beginIndex в буфере cb.

valueType &operator*() const;
Разыменование итератора.
Кидается исключение, если буфер пустой.

iterator &operator=(const iterator &other) noexcept;
Присваивает один итератор другому.

iterator &operator+(int shift) noexcept;
Увеличение итератора на shift.

iterator &operator-(int shift) noexcept;
Уменьшение итератора на shift.

iterator &operator+=(int shift) noexcept;
Увеличение итератора на shift.

iterator &operator-=(int shift) noexcept;
Уменьшает итератора на shift.

iterator &operator++() noexcept;
Увеличение итератора на 1 и возвращает изменённый итератор.

iterator operator++(int) noexcept;
Увеличение итератора на 1 и возвращает копую неизменённого итератора.

iterator &operator--() noexcept;
Уменьшение итератора на 1 и возвращает изменённый итератор.

iterator operator--(int) noexcept;
Уменьшение итератора на 1 и возвращает копую неизменённого итератора.

bool operator==(const iterator &other) const noexcept;
Сравнивает два итератора. Для равенства надо, чтобы они оба указывали на один и тот же элемент одного и того же буфера.

bool operator!=(const iterator &other) const noexcept;
Проверяет на неравенство два итератора. Для равенства надо, чтобы они оба указывали на один и тот же элемент одного и того же буфера.

iterator begin() const noexcept;
Возвращает итератор, указывающий на первый элемент.

iterator end() const noexcept;
Возвращает итератор, указывающий на следующий за последним элемент.
